"""
给定一个单链表，请编写程序将链表元素进行分类排列，使得所有负值元素都排在非负值元素的前面，而 [0, K] 区间内的元素都排在大于 K 的元素前面。但每一类内部元素的顺序是不能改变的。例如：给定链表为 18→7→-4→0→5→-6→10→11→-2，K 为 10，则输出应该为 -4→-6→-2→7→0→5→10→18→11。
输入格式：

每个输入包含一个测试用例。每个测试用例第 1 行给出：第 1 个结点的地址；结点总个数，即正整数N (≤10​5​​)；以及正整数K (≤10​3​​)。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。

接下来有 N 行，每行格式为：

Address Data Next

其中 Address 是结点地址；Data 是该结点保存的数据，为 [−10​5​​,10​5​​] 区间内的整数；Next 是下一结点的地址。题目保证给出的链表不为空。
输出格式：

对每个测试用例，按链表从头到尾的顺序输出重排后的结果链表，其上每个结点占一行，格式与输入相同。
输入样例：

00100 9 10
23333 10 27777
00000 0 99999
00100 18 12309
68237 -6 23333
33218 -4 00000
48652 -2 -1
99999 5 68237
27777 11 48652
12309 7 33218

输出样例：

33218 -4 68237
68237 -6 48652
48652 -2 12309
12309 7 00000
00000 0 99999
99999 5 23333
23333 10 00100
00100 18 27777
27777 11 -1
"""

######################################################################################
"""
本题python 测试点5超时。用网上AC的C++，前5个测试点为3ms，但测试点5位293ms，数据明显大增。
本题注意：
1. 可能只有1个节点，因此第1个点的temp获取下一个节点会出现异常
2. 可能存在废节点，因此最后在输出时，用新列长度为循环指标，而非输入时节点个数指标
"""
######################################################################################

start_address, node_amount, K = [int(i) for i in input().split()]
address = [0] * 100000
for i in range(node_amount):
    temp = [int(i) for i in input().split()]
    address[temp[0]] = temp[1:]
negative, beforeK, afterK = [], [], []
try:
    temp = [start_address, address[start_address][0], address[start_address][1]]
except:
    print("%05d" % temp[0],temp[1],-1)
    exit(0)
while True:
    if temp[1] < 0:
        negative.append([temp[0],temp[1]])
    elif temp[1] <= K:
        beforeK.append([temp[0],temp[1]])
    else:
        afterK.append([temp[0],temp[1]])
    if temp[2] == -1:
        break
    else:
        temp = [temp[2],address[temp[2]][0],address[temp[2]][1]]
merge = negative + beforeK + afterK
for i in range(len(merge)-1):
    print("%05d" % merge[i][0],merge[i][1],"%05d" % merge[i + 1][0])
print("%05d" % merge[-1][0],merge[-1][1],-1)