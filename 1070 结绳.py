"""
给定一段一段的绳子，你需要把它们串成一条绳。每次串连的时候，是把两段绳子对折，再如下图所示套接在一起。这样得到的绳子又被当成是另一段绳子，可以再次对折去跟另一段绳子串连。每次串连后，原来两段绳子的长度就会减半。

rope.jpg

给定 N 段绳子的长度，你需要找出它们能串成的绳子的最大长度。
输入格式：

每个输入包含 1 个测试用例。每个测试用例第 1 行给出正整数 N (2≤N≤10​4​​)；第 2 行给出 N 个正整数，即原始绳段的长度，数字间以空格分隔。所有整数都不超过10​4​​。
输出格式：

在一行中输出能够串成的绳子的最大长度。结果向下取整，即取为不超过最大长度的最近整数。
输入样例：

8
10 15 12 3 4 13 1 15

输出样例：

14
"""

##########################################
"""
这道题数学简化，为使绳子长度尽可能地长，那么长绳子对半损耗需要尽可能少，所以可转化为：最短绳子连接，然后再与次短绳子连接...最终连接最长绳子。
因为有对半损耗，所以最短绳子相连后仍是最短绳子，无需重新排序。
因此又可将模型转化为：将绳子从长到短排序，分别除以2的幂次。
这里需注意，两根最短绳子的相除幂次是一样的，以总数2根绳子为例，各绳长均除以2后相加，而非长的除以2，短的除以4，这是第一次没有AC的原因。
"""
##########################################

N = int(input())
rope = [int(i) for i in input().split()]
rope.sort(reverse=True)
length = 0
div = 1
for i in range(N - 1):
    div *= 2
    length += rope[i] / div
length += rope[N - 1] / div
print(int(length))