"""
当自然数 n 依次取 1、2、3、……、N 时，算式 ⌊n/2⌋+⌊n/3⌋+⌊n/5⌋ 有多少个不同的值？（注：⌊x⌋ 为取整函数，表示不超过 x 的最大自然数，即 x 的整数部分。）
输入格式：

输入给出一个正整数 N（2≤N≤10​4​​）。
输出格式：

在一行中输出题面中算式取到的不同值的个数。
输入样例：

2017

输出样例：

1480
"""

#######################################################
"""
本题有点憋屈，按照下面暴力方法直接可以得到不同值个数，非常简单
在假设算力不够的情况下，因2、3、5最小公倍数为30，可认为30个数为一个组，组与组之间的值得个数应相同（注意每组第一个数0除外），那么得到多少组30，乘每组个数（注意第二组开始后面组的0均应除外，所以应－1），最后加上剩余的个数。虽然通过了样例，但是该方法竟然没有全部成功？？？自我感觉目前算法没有问题？？
    OK,清楚了，原来是列表减1的问题，python中本身末尾的数字已经不包含了！
    此外，当刚好是30的整数倍时，我的方法也是错误的！
"""
#######################################################

l = []
for i in range(1,int(input()) + 1):
    l.append(int(i / 2) + int(i / 3) + int(i / 5))
print(len(set(l)))

"""
l30 = []
for i in range(1,31):
    l30.append(int(i / 2) + int(i / 3) + int(i / 5))
s30 = set(l30)
n = int(input())
s = n // 30
l = n % 30
if s == 0:
    print(len(set(l30[:l])))
elif l == 0:
    print(len(s30) + (len(s30) - 1) * (s - 1))
else:
    print(len(s30) + (len(s30) - 1) * (s - 1) + (len(set(l30[:l])) - 1))
"""

"""
l30 = []
for i in range(1,31):
    l30.append(int(i / 2) + int(i / 3) + int(i / 5))
s30 = set(l30)
n = int(input())
s = n // 30
l = n % 30
if n >= 30:
    #print(len(s30) + (len(s30) - 1) * (s - 1) + (len(set(l30[:l - 1])) - 1))
    print(len(s30) + (len(s30) - 1) * (s - 1) + (len(set(l30[:l])) - 1))
else:
    #print(len(set(l30[:l - 1])))
    print(len(set(l30[:l])))
"""