"""
著名的快速排序算法里有一个经典的划分过程：我们通常采用某种方法取一个元素作为主元，通过交换，把比主元小的元素放到它的左边，比主元大的元素放到它的右边。 给定划分后的 N 个互不相同的正整数的排列，请问有多少个元素可能是划分前选取的主元？

例如给定 $N = 5$, 排列是1、3、2、4、5。则：

    1 的左边没有元素，右边的元素都比它大，所以它可能是主元；
    尽管 3 的左边元素都比它小，但其右边的 2 比它小，所以它不能是主元；
    尽管 2 的右边元素都比它大，但其左边的 3 比它大，所以它不能是主元；
    类似原因，4 和 5 都可能是主元。

因此，有 3 个元素可能是主元。
输入格式：

输入在第 1 行中给出一个正整数 N（≤10​5​​）； 第 2 行是空格分隔的 N 个不同的正整数，每个数不超过 10​9​​。
输出格式：

在第 1 行中输出有可能是主元的元素个数；在第 2 行中按递增顺序输出这些元素，其间以 1 个空格分隔，行首尾不得有多余空格。
输入样例：

5
1 3 2 4 5

输出样例：

3
1 4 5
"""

########################################################################################################
"""
本题即目标是找到1个数，使其大于左边所有数，使其小于右边所有数。
将其分成2步：
从左往右依次遍历，若新加入的数为当前序列的最大数，则将其标记。
从右往左依次遍历，若新加入的数为当前序列的最小数，并且其已经被标记，则其为主元——表明该数在从第一个数至其位置所形成数列中为最大值，在从其位置至最后一个数所形成的数列中为最小值。
#注意2次遍历中，第一个数默认标记，需单独讨论
#第一次做的时候，第二遍遍历又单独升级标记，没有将其直接压入主元组，而是在最后对升级标记再次遍历，导致第2个测试超时
"""
########################################################################################################

N = int(input())
demo = list(map(int,input().split()))
elem = [0] * N
max = demo[0]
elem[0] = 1
for i in range(1,N):
    if demo[i] > max:
        elem[i] = 1
        max = demo[i]
min = demo[N - 1]
major = []
if elem[N - 1] == 1:
    major.append(demo[N - 1])
for i in range(N - 2,-1,-1):
    if demo[i] < min:
        min = demo[i]
        if elem[i] == 1:
            major.append(demo[i])
major.sort()
print(len(major))
major = list(map(str,major))
print(' '.join(major))

#N = int(input())
#demo = list(map(int,input().split()))
#elem = [0] * N
#max = demo[0]
#elem[0] = 1
#for i in range(1,N):
#    if demo[i] > max:
#        elem[i] = 1
#        max = demo[i]
#min = demo[N - 1]
#if elem[N - 1] == 1:
#    elem[N - 1] = 2
#for i in range(N - 2,-1,-1):
#    if demo[i] < min:
#        min = demo[i]
#        if elem[i] == 1:
#            elem[i] = 2
#major = []
#for i in range(N):
#    if elem[i] == 2:
#        major.append(demo[i])
#major.sort()
#print(len(major))
#major = list(map(str,major))
#print(' '.join(major))